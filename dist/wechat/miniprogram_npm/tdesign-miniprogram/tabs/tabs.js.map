{"version":3,"file":"miniprogram_npm/tdesign-miniprogram/tabs/tabs.js","mappings":";;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;AClCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;AC1CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","sources":["webpack:///./miniprogram_npm/tdesign-miniprogram/mixins/touch.js","webpack:///./miniprogram_npm/tdesign-miniprogram/tabs/props.js","webpack:///./miniprogram_npm/tdesign-miniprogram/tabs/tabs.js"],"sourcesContent":["var MinDistance = 10;\nvar getDirection = function (x, y) {\n    if (x > y && x > MinDistance) {\n        return 'horizontal';\n    }\n    if (y > x && y > MinDistance) {\n        return 'vertical';\n    }\n    return '';\n};\nexport default Behavior({\n    methods: {\n        resetTouchStatus: function () {\n            this.direction = '';\n            this.deltaX = 0;\n            this.deltaY = 0;\n            this.offsetX = 0;\n            this.offsetY = 0;\n        },\n        touchStart: function (event) {\n            this.resetTouchStatus();\n            var touch = event.touches[0];\n            this.startX = touch.clientX;\n            this.startY = touch.clientY;\n        },\n        touchMove: function (event) {\n            var touch = event.touches[0];\n            this.deltaX = touch.clientX - this.startX;\n            this.deltaY = touch.clientY - this.startY;\n            this.offsetX = Math.abs(this.deltaX);\n            this.offsetY = Math.abs(this.deltaY);\n            this.direction = getDirection(this.offsetX, this.offsetY);\n        },\n    },\n});\n","var props = {\n    animation: {\n        type: Object,\n    },\n    externalClasses: {\n        type: Array,\n    },\n    showBottomLine: {\n        type: Boolean,\n        value: true,\n    },\n    spaceEvenly: {\n        type: Boolean,\n        value: true,\n    },\n    split: {\n        type: Boolean,\n        value: true,\n    },\n    sticky: {\n        type: Boolean,\n        value: false,\n    },\n    stickyProps: {\n        type: Object,\n    },\n    swipeable: {\n        type: Boolean,\n        value: true,\n    },\n    theme: {\n        type: String,\n        value: 'line',\n    },\n    value: {\n        type: null,\n        value: null,\n    },\n    defaultValue: {\n        type: null,\n    },\n};\nexport default props;\n","import { __extends, __generator } from \"tslib\";\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\")\n        r = Reflect.decorate(decorators, target, key, desc);\n    else\n        for (var i = decorators.length - 1; i >= 0; i--)\n            if (d = decorators[i])\n                r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try {\n            step(generator.next(value));\n        }\n        catch (e) {\n            reject(e);\n        } }\n        function rejected(value) { try {\n            step(generator[\"throw\"](value));\n        }\n        catch (e) {\n            reject(e);\n        } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport { SuperComponent, wxComponent } from '../common/src/index';\nimport props from './props';\nimport config from '../common/config';\nimport touch from '../mixins/touch';\nimport { getRect, uniqueFactory } from '../common/utils';\nvar prefix = config.prefix;\nvar name = prefix + \"-tabs\";\nvar getUniqueID = uniqueFactory('tabs');\nvar Tabs = /** @class */ (function (_super) {\n    __extends(Tabs, _super);\n    function Tabs() {\n        var _this = _super.apply(this, arguments) || this;\n        _this.behaviors = [touch];\n        _this.externalClasses = [\n            prefix + \"-class\",\n            prefix + \"-class-item\",\n            prefix + \"-class-active\",\n            prefix + \"-class-track\",\n            prefix + \"-class-content\",\n        ];\n        _this.relations = {\n            '../tab-panel/tab-panel': {\n                type: 'descendant',\n                linked: function (target) {\n                    this.children.push(target);\n                    this.initChildId();\n                    target.index = this.children.length - 1;\n                    this.updateTabs();\n                },\n                unlinked: function (target) {\n                    var _this = this;\n                    this.children = this.children.filter(function (item) { return item.index !== target.index; });\n                    this.updateTabs(function () { return _this.setTrack(); });\n                    this.initChildId();\n                },\n            },\n        };\n        _this.properties = props;\n        _this.controlledProps = [\n            {\n                key: 'value',\n                event: 'change',\n            },\n        ];\n        _this.observers = {\n            value: function (name) {\n                if (name !== this.getCurrentName()) {\n                    this.setCurrentIndexByName(name);\n                }\n            },\n        };\n        _this.data = {\n            prefix: prefix,\n            classPrefix: name,\n            tabs: [],\n            currentIndex: -1,\n            trackStyle: '',\n            offset: 0,\n            scrollLeft: 0,\n            tabID: '',\n            placement: 'top',\n        };\n        _this.lifetimes = {\n            created: function () {\n                this.children = this.children || [];\n            },\n            attached: function () {\n                var _this = this;\n                wx.nextTick(function () {\n                    _this.setTrack();\n                });\n                getRect(this, \".\" + name).then(function (rect) {\n                    _this.containerWidth = rect.width;\n                });\n                this.setData({\n                    tabID: getUniqueID(),\n                });\n            },\n        };\n        _this.methods = {\n            onScroll: function (e) {\n                var scrollLeft = e.detail.scrollLeft;\n                this.setData({\n                    scrollLeft: scrollLeft,\n                });\n            },\n            updateTabs: function (cb) {\n                var children = this.children;\n                var tabs = children.map(function (child) { return child.data; });\n                tabs.forEach(function (item) {\n                    if (typeof item.icon === 'string') {\n                        item.icon = { name: item.icon };\n                    }\n                });\n                this.setData({ tabs: tabs }, cb);\n                this.setCurrentIndexByName(this.properties.value);\n            },\n            setCurrentIndexByName: function (name) {\n                var children = this.children;\n                var index = children.findIndex(function (child) { return child.getComputedName() === \"\" + name; });\n                if (index > -1) {\n                    this.setCurrentIndex(index);\n                }\n            },\n            setCurrentIndex: function (index) {\n                var _this = this;\n                if (index <= -1 || index >= this.children.length)\n                    return;\n                this.children.forEach(function (child, idx) {\n                    var isActive = index === idx;\n                    if (isActive !== child.data.active) {\n                        child.render(isActive, _this);\n                    }\n                });\n                if (this.data.currentIndex === index)\n                    return;\n                this.setData({\n                    currentIndex: index,\n                });\n                this.setTrack();\n            },\n            getCurrentName: function () {\n                if (this.children) {\n                    var activeTab = this.children[this.data.currentIndex];\n                    if (activeTab) {\n                        return activeTab.getComputedName();\n                    }\n                }\n            },\n            calcScrollOffset: function (containerWidth, targetLeft, targetWidth, offset) {\n                return offset + targetLeft - (1 / 2) * containerWidth + targetWidth / 2;\n            },\n            getTrackSize: function () {\n                var _this = this;\n                return new Promise(function (resolve, reject) {\n                    if (_this.trackWidth) {\n                        resolve(_this.trackWidth);\n                        return;\n                    }\n                    getRect(_this, \".\" + prefix + \"-tabs__track\")\n                        .then(function (res) {\n                        if (res) {\n                            _this.trackWidth = res.width;\n                            resolve(_this.trackWidth);\n                        }\n                    })\n                        .catch(reject);\n                });\n            },\n            setTrack: function () {\n                return __awaiter(this, void 0, void 0, function () {\n                    var children, currentIndex, res, rect, count_1, distance_1, totalSize_1, offset, maxOffset, trackLineWidth, err_1;\n                    return __generator(this, function (_a) {\n                        switch (_a.label) {\n                            case 0:\n                                children = this.children;\n                                if (!children)\n                                    return [2 /*return*/];\n                                currentIndex = this.data.currentIndex;\n                                if (currentIndex <= -1)\n                                    return [2 /*return*/];\n                                _a.label = 1;\n                            case 1:\n                                _a.trys.push([1, 5, , 6]);\n                                return [4 /*yield*/, getRect(this, \".\" + prefix + \"-tabs__item\", true)];\n                            case 2:\n                                res = _a.sent();\n                                rect = res[currentIndex];\n                                if (!rect)\n                                    return [2 /*return*/];\n                                count_1 = 0;\n                                distance_1 = 0;\n                                totalSize_1 = 0;\n                                res.forEach(function (item) {\n                                    if (count_1 < currentIndex) {\n                                        distance_1 += item.width;\n                                        count_1 += 1;\n                                    }\n                                    totalSize_1 += item.width;\n                                });\n                                if (this.containerWidth) {\n                                    offset = this.calcScrollOffset(this.containerWidth, rect.left, rect.width, this.data.scrollLeft);\n                                    maxOffset = totalSize_1 - this.containerWidth;\n                                    this.setData({\n                                        offset: Math.min(Math.max(offset, 0), maxOffset),\n                                    });\n                                }\n                                if (!(this.data.theme === 'line')) return [3 /*break*/, 4];\n                                return [4 /*yield*/, this.getTrackSize()];\n                            case 3:\n                                trackLineWidth = _a.sent();\n                                distance_1 += (rect.width - trackLineWidth) / 2;\n                                _a.label = 4;\n                            case 4:\n                                this.setData({\n                                    trackStyle: \"-webkit-transform: translateX(\" + distance_1 + \"px);\\n            transform: translateX(\" + distance_1 + \"px);\\n          \",\n                                });\n                                return [3 /*break*/, 6];\n                            case 5:\n                                err_1 = _a.sent();\n                                this.triggerEvent('error', err_1);\n                                return [3 /*break*/, 6];\n                            case 6: return [2 /*return*/];\n                        }\n                    });\n                });\n            },\n            onTabTap: function (event) {\n                var index = event.currentTarget.dataset.index;\n                this.changeIndex(index);\n            },\n            onTouchStart: function (event) {\n                if (!this.properties.swipeable)\n                    return;\n                this.touchStart(event);\n            },\n            onTouchMove: function (event) {\n                if (!this.properties.swipeable)\n                    return;\n                this.touchMove(event);\n            },\n            onTouchEnd: function () {\n                if (!this.properties.swipeable)\n                    return;\n                var _a = this, direction = _a.direction, deltaX = _a.deltaX, offsetX = _a.offsetX;\n                var minSwipeDistance = 50;\n                if (direction === 'horizontal' && offsetX >= minSwipeDistance) {\n                    var index = this.getAvailableTabIndex(deltaX);\n                    if (index !== -1) {\n                        this.changeIndex(index);\n                    }\n                }\n            },\n            onTouchScroll: function (event) {\n                this._trigger('scroll', event.detail);\n            },\n            changeIndex: function (index) {\n                var currentTab = this.data.tabs[index];\n                var value = currentTab.value, label = currentTab.label;\n                if (!(currentTab === null || currentTab === void 0 ? void 0 : currentTab.disabled) && index !== this.data.currentIndex) {\n                    this._trigger('change', { value: value, label: label });\n                }\n                this._trigger('click', { value: value, label: label });\n            },\n            getAvailableTabIndex: function (deltaX) {\n                var step = deltaX > 0 ? -1 : 1;\n                var _a = this.data, currentIndex = _a.currentIndex, tabs = _a.tabs;\n                var len = tabs.length;\n                for (var i = step; currentIndex + step >= 0 && currentIndex + step < len; i += step) {\n                    var newIndex = currentIndex + i;\n                    if (newIndex >= 0 && newIndex < len && tabs[newIndex]) {\n                        if (!tabs[newIndex].disabled) {\n                            return newIndex;\n                        }\n                    }\n                    else {\n                        return currentIndex;\n                    }\n                }\n                return -1;\n            },\n        };\n        return _this;\n    }\n    Tabs.prototype.initChildId = function () {\n        var _this = this;\n        this.children.forEach(function (item, index) {\n            item.setId(_this.data.tabID + \"_panel_\" + index);\n        });\n    };\n    return Tabs;\n}(SuperComponent));\nTabs = __decorate([\n    wxComponent()\n], Tabs);\nexport default Tabs;\n"],"names":[],"sourceRoot":""}