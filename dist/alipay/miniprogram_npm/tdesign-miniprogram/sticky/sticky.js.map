{"version":3,"file":"miniprogram_npm/tdesign-miniprogram/sticky/sticky.js","mappings":";;;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;AC3CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;ACrBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","sources":["webpack:///./miniprogram_npm/tdesign-miniprogram/mixins/page-scroll.js","webpack:///./miniprogram_npm/tdesign-miniprogram/sticky/props.js","webpack:///./miniprogram_npm/tdesign-miniprogram/sticky/sticky.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar Behavior = require('/Users/zolad/work/app/ctrip/fly/WeChatProjects/weixin-pages-morjs/node_modules/@morjs/runtime-mini/lib/common/behaviorOrMixin.js').Behavior;\nconst utils_1 = require(\"../common/utils\");\nconst onPageScroll = function (event) {\n    const page = (0, utils_1.getCurrentPage)();\n    if (!page)\n        return;\n    const { pageScroller } = page;\n    pageScroller === null || pageScroller === void 0 ? void 0 : pageScroller.forEach((scroller) => {\n        if (typeof scroller === 'function') {\n            scroller(event);\n        }\n    });\n};\nexports.default = (funcName = 'onScroll') => {\n    return Behavior({\n        attached() {\n            var _a;\n            const page = (0, utils_1.getCurrentPage)();\n            if (!page)\n                return;\n            const bindScroller = (_a = this[funcName]) === null || _a === void 0 ? void 0 : _a.bind(this);\n            if (bindScroller) {\n                this._pageScroller = bindScroller;\n            }\n            if (Array.isArray(page.pageScroller)) {\n                page.pageScroller.push(bindScroller);\n            }\n            else {\n                page.pageScroller =\n                    typeof page.onPageScroll === 'function' ? [page.onPageScroll.bind(page), bindScroller] : [bindScroller];\n            }\n            page.onPageScroll = onPageScroll;\n        },\n        detached() {\n            var _a;\n            const page = (0, utils_1.getCurrentPage)();\n            if (!page)\n                return;\n            page.pageScroller = ((_a = page.pageScroller) === null || _a === void 0 ? void 0 : _a.filter((item) => item !== this._pageScroller)) || [];\n        },\n    });\n};\n","\"use strict\";\nconst props = {\n  container: {\n    type: null\n  },\n  disabled: {\n    type: Boolean,\n    value: false\n  },\n  externalClasses: {\n    type: Array\n  },\n  offsetTop: {\n    type: Number,\n    value: 0\n  },\n  zIndex: {\n    type: Number,\n    value: 99\n  }\n};\nexport default props;\n","var __MOR_API__ = require('@morjs/api').mor;\n\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\")\n        r = Reflect.decorate(decorators, target, key, desc);\n    else\n        for (var i = decorators.length - 1; i >= 0; i--)\n            if (d = decorators[i])\n                r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nimport { SuperComponent, wxComponent } from '../common/src/index';\nimport props from './props';\nimport config from '../common/config';\nimport pageScrollMixin from '../mixins/page-scroll';\nimport { getRect } from '../common/utils';\nconst { prefix } = config;\nconst name = `${prefix}-sticky`;\nconst ContainerClass = `.${name}`;\nlet Sticky = class Sticky extends SuperComponent {\n    constructor() {\n        super(...arguments);\n        this.externalClasses = [`${prefix}-class`, `${prefix}-class-content`];\n        this.properties = props;\n        this.behaviors = [pageScrollMixin()];\n        this.observers = {\n            'offsetTop, disabled, container'() {\n                this.onScroll();\n            },\n        };\n        this.data = {\n            prefix,\n            classPrefix: name,\n            containerStyle: '',\n            contentStyle: '',\n        };\n        this.methods = {\n            onScroll(event) {\n                const { scrollTop } = event || {};\n                const { container, offsetTop, disabled } = this.properties;\n                if (disabled) {\n                    this.setDataAfterDiff({\n                        isFixed: false,\n                        transform: 0,\n                    });\n                    return;\n                }\n                this.scrollTop = scrollTop || this.scrollTop;\n                if (typeof container === 'function') {\n                    Promise.all([getRect(this, ContainerClass), this.getContainerRect()]).then(([root, container]) => {\n                        if (!root || !container)\n                            return;\n                        if (offsetTop + root.height > container.height + container.top) {\n                            this.setDataAfterDiff({\n                                isFixed: false,\n                                transform: container.height - root.height,\n                            });\n                        }\n                        else if (offsetTop >= root.top) {\n                            this.setDataAfterDiff({\n                                isFixed: true,\n                                height: root.height,\n                                transform: 0,\n                            });\n                        }\n                        else {\n                            this.setDataAfterDiff({ isFixed: false, transform: 0 });\n                        }\n                    });\n                    return;\n                }\n                getRect(this, ContainerClass).then((root) => {\n                    if (!root)\n                        return;\n                    if (offsetTop >= root.top) {\n                        this.setDataAfterDiff({ isFixed: true, height: root.height });\n                        this.transform = 0;\n                    }\n                    else {\n                        this.setDataAfterDiff({ isFixed: false });\n                    }\n                });\n            },\n            setDataAfterDiff(data) {\n                const { offsetTop } = this.properties;\n                const { containerStyle: prevContainerStyle, contentStyle: prevContentStyle } = this.data;\n                const { isFixed, height, transform } = data;\n                __MOR_API__.nextTick(() => {\n                    let containerStyle = '';\n                    let contentStyle = '';\n                    if (isFixed) {\n                        containerStyle += `height:${height}px;`;\n                        contentStyle += `position:fixed;top:${offsetTop}px;left:0;right:0;`;\n                    }\n                    if (transform) {\n                        const translate = `translate3d(0, ${transform}px, 0)`;\n                        contentStyle += `-webkit-transform:${translate};transform:${translate};`;\n                    }\n                    if (prevContainerStyle !== containerStyle || prevContentStyle !== contentStyle) {\n                        this.setData({ containerStyle, contentStyle });\n                    }\n                    this.triggerEvent('scroll', {\n                        scrollTop: this.scrollTop,\n                        isFixed,\n                    });\n                });\n            },\n            getContainerRect() {\n                const nodesRef = this.properties.container();\n                return new Promise((resolve) => nodesRef.boundingClientRect(resolve).exec());\n            },\n        };\n    }\n    ready() {\n        this.onScroll();\n    }\n};\nSticky = __decorate([\n    wxComponent()\n], Sticky);\nexport default Sticky;\n"],"names":[],"sourceRoot":""}