{"version":3,"file":"components/tdesign-miniprogram/icon/icon.js","mappings":";;;;;;;;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;AC9OA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;ACtDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","sources":["webpack:///./components/tdesign-miniprogram/common/utils.js","webpack:///./components/tdesign-miniprogram/icon/icon.js","webpack:///./components/tdesign-miniprogram/icon/props.js"],"sourcesContent":["var __MOR_API__ = require('@morjs/api').mor;\n\nimport { prefix } from './config';\nconst systemInfo = __MOR_API__.getSystemInfoSync();\nexport const debounce = function (func, wait = 500) {\n    let timerId;\n    return function (...rest) {\n        if (timerId) {\n            clearTimeout(timerId);\n        }\n        timerId = setTimeout(() => {\n            func.apply(this, rest);\n        }, wait);\n    };\n};\nexport const throttle = (func, wait = 100, options = null) => {\n    let previous = 0;\n    let timerid = null;\n    if (!options) {\n        options = {\n            leading: true,\n        };\n    }\n    return function (...args) {\n        const now = Date.now();\n        if (!previous && !options.leading)\n            previous = now;\n        const remaining = wait - (now - previous);\n        const context = this;\n        if (remaining <= 0) {\n            if (timerid) {\n                clearTimeout(timerid);\n                timerid = null;\n            }\n            previous = now;\n            func.apply(context, args);\n        }\n    };\n};\nexport const classNames = function (...args) {\n    const hasOwn = {}.hasOwnProperty;\n    const classes = [];\n    args.forEach((arg) => {\n        if (!arg)\n            return;\n        const argType = typeof arg;\n        if (argType === 'string' || argType === 'number') {\n            classes.push(arg);\n        }\n        else if (Array.isArray(arg) && arg.length) {\n            const inner = classNames(...arg);\n            if (inner) {\n                classes.push(inner);\n            }\n        }\n        else if (argType === 'object') {\n            for (const key in arg) {\n                if (hasOwn.call(arg, key) && arg[key]) {\n                    classes.push(key);\n                }\n            }\n        }\n    });\n    return classes.join(' ');\n};\nexport const styles = function (styleObj) {\n    return Object.keys(styleObj)\n        .map((styleKey) => `${styleKey}: ${styleObj[styleKey]}`)\n        .join('; ');\n};\nexport const getAnimationFrame = function (context, cb) {\n    return __MOR_API__.createSelectorQuery()\n        .in(context)\n        .selectViewport()\n        .boundingClientRect()\n        .exec(() => {\n        cb();\n    });\n};\nexport const getRect = function (context, selector, needAll = false) {\n    return new Promise((resolve, reject) => {\n        __MOR_API__.createSelectorQuery()\n            .in(context)[needAll ? 'selectAll' : 'select'](selector)\n            .boundingClientRect((rect) => {\n            if (rect) {\n                resolve(rect);\n            }\n            else {\n                reject(rect);\n            }\n        })\n            .exec();\n    });\n};\nexport const isNumber = function (value) {\n    return /^\\d+(\\.\\d+)?$/.test(value);\n};\nexport const isNull = function (value) {\n    return value === null;\n};\nexport const isUndefined = (value) => typeof value === 'undefined';\nexport const isDef = function (value) {\n    return !isUndefined(value) && !isNull(value);\n};\nexport const addUnit = function (value) {\n    if (!isDef(value)) {\n        return undefined;\n    }\n    value = String(value);\n    return isNumber(value) ? `${value}px` : value;\n};\nexport const getCharacterLength = (type, char, max) => {\n    const str = String(char !== null && char !== void 0 ? char : '');\n    if (str.length === 0) {\n        return {\n            length: 0,\n            characters: '',\n        };\n    }\n    if (type === 'maxcharacter') {\n        let len = 0;\n        for (let i = 0; i < str.length; i += 1) {\n            let currentStringLength = 0;\n            if (str.charCodeAt(i) > 127 || str.charCodeAt(i) === 94) {\n                currentStringLength = 2;\n            }\n            else {\n                currentStringLength = 1;\n            }\n            if (len + currentStringLength > max) {\n                return {\n                    length: len,\n                    characters: str.slice(0, i),\n                };\n            }\n            len += currentStringLength;\n        }\n        return {\n            length: len,\n            characters: str,\n        };\n    }\n    else if (type === 'maxlength') {\n        const length = str.length > max ? max : str.length;\n        return {\n            length,\n            characters: str.slice(0, length),\n        };\n    }\n    return {\n        length: str.length,\n        characters: str,\n    };\n};\nexport const chunk = (arr, size) => Array.from({ length: Math.ceil(arr.length / size) }, (v, i) => arr.slice(i * size, i * size + size));\nexport const getInstance = function (context, selector) {\n    if (!context) {\n        const pages = getCurrentPages();\n        const page = pages[pages.length - 1];\n        context = page.$$basePage || page;\n    }\n    const instance = context ? context.selectComponent(selector) : null;\n    if (!instance) {\n        console.warn('未找到组件,请检查selector是否正确');\n        return null;\n    }\n    return instance;\n};\nexport const unitConvert = (value) => {\n    var _a;\n    if (typeof value === 'string') {\n        if (value.includes('rpx')) {\n            return (parseInt(value, 10) * ((_a = systemInfo === null || systemInfo === void 0 ? void 0 : systemInfo.screenWidth) !== null && _a !== void 0 ? _a : 750)) / 750;\n        }\n        return parseInt(value, 10);\n    }\n    return value;\n};\nexport const setIcon = (iconName, icon, defaultIcon) => {\n    if (icon) {\n        if (typeof icon === 'string') {\n            return {\n                [`${iconName}Name`]: icon,\n                [`${iconName}Data`]: {},\n            };\n        }\n        else if (typeof icon === 'object') {\n            return {\n                [`${iconName}Name`]: '',\n                [`${iconName}Data`]: icon,\n            };\n        }\n        else {\n            return {\n                [`${iconName}Name`]: defaultIcon,\n                [`${iconName}Data`]: {},\n            };\n        }\n    }\n    return {\n        [`${iconName}Name`]: '',\n        [`${iconName}Data`]: {},\n    };\n};\nexport const isBool = (val) => typeof val === 'boolean';\nexport const isObject = (val) => typeof val === 'object' && val != null;\nexport const isString = (val) => typeof val === 'string';\nexport const toCamel = (str) => str.replace(/-(\\w)/g, (match, m1) => m1.toUpperCase());\nexport const getCurrentPage = function () {\n    const pages = getCurrentPages();\n    return pages[pages.length - 1];\n};\nexport const uniqueFactory = (compName) => {\n    let number = 0;\n    return () => `${prefix}_${compName}_${number++}`;\n};\nexport const calcIcon = (icon, defaultIcon) => {\n    if ((isBool(icon) && icon && defaultIcon) || isString(icon)) {\n        return { name: isBool(icon) ? defaultIcon : icon };\n    }\n    if (isObject(icon)) {\n        return icon;\n    }\n    return null;\n};\nexport const isOverSize = (size, sizeLimit) => {\n    var _a;\n    if (!sizeLimit)\n        return false;\n    const base = 1000;\n    const unitMap = {\n        B: 1,\n        KB: base,\n        MB: base * base,\n        GB: base * base * base,\n    };\n    const computedSize = typeof sizeLimit === 'number' ? sizeLimit * base : (sizeLimit === null || sizeLimit === void 0 ? void 0 : sizeLimit.size) * unitMap[(_a = sizeLimit === null || sizeLimit === void 0 ? void 0 : sizeLimit.unit) !== null && _a !== void 0 ? _a : 'KB'];\n    return size > computedSize;\n};\n","var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\")\n        r = Reflect.decorate(decorators, target, key, desc);\n    else\n        for (var i = decorators.length - 1; i >= 0; i--)\n            if (d = decorators[i])\n                r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nimport { SuperComponent, wxComponent } from '../common/src/index';\nimport config from '../common/config';\nimport props from './props';\nimport { styles, addUnit } from '../common/utils';\nconst { prefix } = config;\nconst name = `${prefix}-icon`;\nlet Icon = class Icon extends SuperComponent {\n    constructor() {\n        super(...arguments);\n        this.externalClasses = [`${prefix}-class`];\n        this.properties = props;\n        this.data = {\n            componentPrefix: prefix,\n            classPrefix: name,\n            isImage: false,\n            iconStyle: undefined,\n        };\n        this.observers = {\n            'name, color, size, style'() {\n                this.setIconStyle();\n            },\n        };\n        this.methods = {\n            onTap(event) {\n                this.triggerEvent('click', event.detail);\n            },\n            setIconStyle() {\n                const { name, color, size } = this.properties;\n                const isImage = name.indexOf('/') !== -1;\n                const sizeValue = addUnit(size);\n                const sizeStyle = isImage ? { width: sizeValue, height: sizeValue } : {};\n                const colorStyle = color ? { color: color } : {};\n                const fontStyle = size ? { 'font-size': sizeValue } : {};\n                this.setData({\n                    isImage,\n                    iconStyle: `${styles(Object.assign(Object.assign(Object.assign({}, colorStyle), fontStyle), sizeStyle))}`,\n                });\n            },\n        };\n    }\n};\nIcon = __decorate([\n    wxComponent()\n], Icon);\nexport default Icon;\n","\"use strict\";\nconst props = {\n  color: {\n    type: String,\n    value: \"\"\n  },\n  name: {\n    type: String,\n    value: \"\",\n    required: true\n  },\n  size: {\n    type: String,\n    value: \"\"\n  },\n  prefix: {\n    type: String,\n    value: void 0\n  }\n};\nexport default props;\n"],"names":[],"sourceRoot":""}